[] Firstly array for ten "pointers" for name table (labels)
[] Dump labels
[] Function to find pointer by name
[] Сначала сделать скачки по цифрам
[] Если метка слишком длинная (> 10 символов) - SYNTAX ERROR
[] Если метка повторяется - SYNTAX ERROR
Функции, тьюринг полнота, прыжки, регистры
[] fscanf --> fread & sscanf
[] make debug submodule
[] NDEBUG VERSION FOR STACK
    i think it`s even better to make ndump, ncanary, nhash ...
[] побитовые операции
[] Добавить вывод в какой строке ошибка и вывести её

[x] Облизать версию без регистров
[x] Добавить регистры
    [x] Изменить функцию push
        [x] Если аргумент регистр, то изменить push: 1 -> push reg
        [x] AX BX CX DX - следующий для push элемент будет не числом, а индексом регистра
        [x] Будет четыре регистра для использования
    [x] В процессоре добавить массив регистров - в main создать массив stack_type
    [x] Отдельный switch для push регистра
    [x] Дизассемблер
[x] Починить сабмодули или вообще нахуй их, просто папки из spu_ скопировать и мозги не трахать
[] Оперативка - насколько понял (попросить расшар) - это просто отдельный массив RAM с данными, в который можно только пушить и попать PUSHM POPM
   Расшар: оперативка это массив или стэк и нахуй она нужна? (предположение: чтобы данные хранились отдельно от команд - заебись, так и прыжки делать проще)
[] После добавления оперативки нужно будет разбить индекс на два: общий индекс, индекс команд
[] Jumps
    [] Я должен прыгнуть в конкретное место или на строчку
    [x] Создаем массив регистров - структур, где первое - имя, второе - строка
    [] Это будет в asm - дополнительный if, в котором будет команда прыжка и значение - на какую строчку.
       Массив labels формируется в processor - там же создается массив команд и массив аргументов(оперативка)
    [] ой а в Дизассемблере у меня не будет названий jump-f это плохо.. наверное. Надо спросить у ребят их вообще
       надо возвращать в asm или можно чиселки хуйнуть и не париться
    [] Двойной проход по коду - можно сделать флаг, который при встрече jump-a будет проходить 2-й раз
       или не ебаться и просто пройтись два раза
    [] Первый проход
        [] видим название метки (смотри на двоеточие в конце - добавить в switch asm) - добавляем в структуру
        [] для начала можно сделать 10 меток, максимальная длина метки - 15, иначе syntax error
        [] Если чел добавил вторую существующую метку - бан. Заполним массив названий отравленными значениями и
           будем сравнивать с ними перед тем как совершить запись
        [] syntax error - хуй знает мб ошибка сама вылезит, потому что : не влезет в мою строку, или
           пиздец - он просто не схавает строчку, тогда надо будет отдельно чекать результат
           fscanf и выдавать ошибку если он 0.
        [] если вижу jmp на первом проходе - ничего не делаю
    [] Второй проход - тут уже просто исполняем код, у нас всё для этого есть
       Только вот тут надо добавить избегание меток :/ либо флаг для второго прохода - чтобы он не добавлял их заново и не
       вылазила syntax error, либо смотреть на совпадение ip метки и нынешнего ip - если совпадают, то всё ок, нет - убить нахуй
    [] IN  - ввод числа в push
    [] JA/JE/.../JNE - прыгнуть на строку если (смотри конспект)
    [] попробовать код из конспекта
    [] Добавить прыжки на индекс строки
    [] Сделать Функции CALL ... RETURN - смотри конспект - после того как увидели функцию - записали куда она должна возвращаться в массив меток
    [] адреса возврата хранятся в стэке - то есть мы перед тем как уйти в функцию добавляем место возврата в стэк (он отдельный или как?)
       наверно просто при выходе из функции идти в метку
[] Теневой регистр - нулевая ячейка массива регистров
.
.
.
[] SPU структура с массивом команд и регистров
[] Sanitizer
[] makefile не работает без папки build

Вопросы Максу:
[] Как запушить изменения в сабмодули
[] JMP - введите строку, на которую надо прыгнуть (или конкретное место? - узнать)
