[x] Сначала сделать скачки по цифрам
[x] Если метка слишком длинная (> 10 символов) - SYNTAX ERROR
[x] Если метка повторяется - SYNTAX ERROR
Функции, тьюринг полнота, прыжки, регистры
[x] fscanf --> fread & sscanf

[x] Облизать версию без регистров
[x] Добавить регистры
    [x] Изменить функцию push
        [x] Если аргумент регистр, то изменить push: 1 -> push reg
        [x] AX BX CX DX - следующий для push элемент будет не числом, а индексом регистра
        [x] Будет четыре регистра для использования
    [x] В процессоре добавить массив регистров - в main создать массив stack_type
    [x] Отдельный switch для push регистра
    [x] Дизассемблер
[x] Починить сабмодули
[x] Jumps
    [x] Я должен прыгнуть в конкретное место или на строчку
    [x] Создаем массив регистров - структур, где первое - имя, второе - строка
    [x] Это будет в asm - дополнительный if, в котором будет команда прыжка и значение - на какую строчку.
       Массив labels формируется в processor - там же создается массив команд и массив аргументов(оперативка)
    [x] в Дизассемблере у меня не будет названий jump-f это плохо.. надо возвращать в asm или можно чиселки и не париться
    [x] Двойной проход по коду - можно сделать флаг, который при встрече jump-a будет проходить 2-й раз
    [x] Первый проход
        [x] видим название метки (смотри на двоеточие в конце - добавить в switch asm) - добавляем в структуру
        [x] для начала можно сделать 10 меток, максимальная длина метки - 15, иначе syntax error
        [x] Если юзер добавил вторую существующую метку - бан. Заполним массив названий отравленными значениями и
           будем сравнивать с ними перед тем как совершить запись
        [x] если вижу jmp на первом проходе - ничего не делаю
    [x] Второй проход - тут уже просто исполняем код, у нас всё для этого есть
       Только вот тут надо добавить избегание меток :/ либо флаг для второго прохода - чтобы он не добавлял их заново и не
       вылазила syntax error, либо смотреть на совпадение ip метки и нынешнего ip - если совпадают, то всё ок, нет - убить
    [x] PRINT function - pop and push
    [x] IN  - ввод числа в push
    [x] Сделать ввод файла через консоль
    [x] JA/JE/.../JNE - прыгнуть на строку если (смотри конспект)
    [x] попробовать код из конспекта
    [x] А что если метка без вызова, вызов без метки? - нужно добавить ошибки
    [x] Сделать Функции CALL ... RETURN - смотри конспект - после того как увидели функцию - записали куда она должна возвращаться в массив меток
       адреса возврата хранятся в стэке - то есть мы перед тем как уйти в функцию добавляем место возврата в стэк (он отдельный или как?)
       наверно просто при выходе из функции идти в метку
[] comments
[x] add sqrt command
[x] побитовые операции
[x] make exception on [AX + 5] in text_processing
[x] Bin and Asm in build
[x] Пропуск пустых строчек
[x] Добавить тест на то, что юзер забыл hlt
[x] Теневой регистр - нулевая ячейка массива регистров
[x] Сделать задержку между командами
[] make output line of ERROR and It`s prototipe in assembly
[] strcmp из онегина?
[] code generator
[x] SPU структура с массивом команд и регистров
[] Sanitizer
[x] makefile не работает без папки build
[] Прерывать stack при ошибке в stackOK ? или починить hash
[] make debug submodule
[] NDEBUG VERSION FOR STACK
    i think it`s even better to make ndump, ncanary, nhash itc
[] redo submodule processing in stack ("#include")
[] should i do flags with bool type
[] main processor
